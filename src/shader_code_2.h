/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_CODE_2_H_
# define SHADER_CODE_2_H_

const char *shader_2_frag =
 "#version 420\n"
 "out vec4 f;"
 "in vec4 gl_Color;\n"
 "#define MIN_DIST 0.01\n"
 "#define STEP_MULTIPLIER 0.9\n"
 "#define NORMAL_OFFSET 0.01\n"
 "#define MAX_STEPS 64\n"
 "#define MAX_STEPS_SHADOW 32\n"
 "#define SHADOW_OFFSET 0.02\n"
 "#define SHADOW_HARDNESS 32.0\n"
 "vec3 n(float v)"
 "{"
   "return vec3(sin(v)+2.*sin(2.*v),cos(v)-2.*cos(2.*v),-sin(3.*v));"
 "}"
 "vec4 n(vec4 v,vec4 s,float y)"
 "{"
   "float S=clamp(.5+.5*(s.w-v.w)/y,0.,1.);"
   "return mix(s,v,S)-vec4(0.,0.,0.,y*S*(1.-S));"
 "}"
 "vec3 v(vec3 v)"
 "{"
   "float S=sin(dot(v,vec3(7,157,113)));"
   "return fract(vec3(2097152,262144,32768)*S);"
 "}"
 "vec4 s(vec3 s)"
 "{"
   "float S=gl_Color.x*3000.*10.;"
   "vec4 i=vec4(0.);"
   "i.xyz=vec3(.3);"
   "i.w=min(min(s.y,-abs(s.z)+2.),-abs(s.x)+2.);"
   "vec4 y=i;"
   "for(int M=0;M<3;M++)"
     "{"
       "vec3 m=n(S*float(M+1))*.2;"
       "if(M==1)"
         "m=m.zxy;"
       "if(M==2)"
         "m=m.zxy;"
       "m.y+=1.2;"
       "float x=.3;"
       "x+=(sin(s.x*40.)+cos(s.z*40.)+sin(s.y*40.))*.01;"
       "vec3 w=vec3(1.),c=vec3(.7,.15,.1),z=w;"
       "x+=(v(s)*.003).x;"
       "vec4 T=vec4(z,length(m-s)-x);"
       "y=n(y,T,.3);"
     "}"
   "return y;"
 "}"
 "vec4 e(vec2 S)"
 "{"
   "float M=gl_Color.x*3000.*10.;"
   "vec2 m=(2.*S.xy-vec2(1280.,720.))/vec2(1280.,720.);"
   "float y=1.;"
   "vec3 w=vec3(sin(y)*-1.75,1.4+cos(0.)+2.,cos(y)*-1.75),i=w;"
   "i.y-=2.;"
   "float x=sin(M*5.);"
   "x=x*x;"
   "i.x+=x*.01;"
   "vec3 T=vec3(0.,1.,0.),c=normalize(T-i),z=normalize(cross(c,vec3(0.,1.,0.))),l=normalize(cross(z,c)),n=i+c,d=n+m.x*z+m.y*l,r=normalize(d-i);"
   "r+=v(r*.01)*.002;"
   "vec3 a=i;"
   "float k=0.,g=1.,b=float(MAX_STEPS);"
   "for(int N=0;N<MAX_STEPS;N++)"
     "{"
       "g=s(a).w;"
       "k+=g*STEP_MULTIPLIER;"
       "a=i+r*k;"
       "if(g<MIN_DIST)"
         "{"
           "b=float(N);"
           "break;"
         "}"
     "}"
   "vec2 N=vec2(NORMAL_OFFSET,0.);"
   "vec3 e=normalize(vec3(s(a+N.xyy).w-s(a-N.xyy).w,s(a+N.yxy).w-s(a-N.yxy).w,s(a+N.yyx).w-s(a-N.yyx).w)),o=i+r*k+e*SHADOW_OFFSET,t=o,E=normalize(w-a);"
   "float A=length(w-a),O=1.;"
   "k=0.;"
   "for(int P=0;P<MAX_STEPS_SHADOW;P++)"
     "{"
       "g=s(t).w;"
       "k+=g*STEP_MULTIPLIER;"
       "t=o+E*k;"
       "if(g<MIN_DIST)"
         "{"
           "O=0.;"
           "break;"
         "}"
       "O=min(O,SHADOW_HARDNESS*g/k);"
       "if(k>=A)"
         "{"
           "break;"
         "}"
       "if(P==MAX_STEPS_SHADOW-1)"
         "O=0.;"
     "}"
   "float P=max(0.,dot(e,E))*O+.1;"
   "vec3 I=P*s(a).xyz;"
   "float D=length(a-i);"
   "vec4 H=vec4(I.xyz,0.);"
   "float F=.4*abs(1.-length(i-T)/D);"
   "F=max(.05,min(1.75,F));"
   "return vec4(H.xyz,F);"
 "}"
 "void main()"
 "{"
   "f=vec4(0.);"
   "for(int i=0;i<3;i++)"
     "f+=e(gl_FragCoord.xy+v(vec3(i)).xy);"
   "f/=3.;"
 "}";

#endif // SHADER_CODE_2_H_
