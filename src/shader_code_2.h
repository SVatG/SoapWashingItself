/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_CODE_2_H_
# define SHADER_CODE_2_H_

const char *shader_2_frag =
 "#version 420\n"
 "out vec4 f;"
 "in vec4 gl_Color;\n"
 "#define MIN_DIST 0.01\n"
 "#define STEP_MULTIPLIER 0.9\n"
 "#define NORMAL_OFFSET 0.01\n"
 "#define MAX_STEPS 64\n"
 "#define MAX_STEPS_SHADOW 32\n"
 "#define SHADOW_OFFSET 0.02\n"
 "#define SHADOW_HARDNESS 32.0\n"
 "vec3 n(float v)"
 "{"
   "return vec3(sin(v)+2.*sin(2.*v),cos(v)-2.*cos(2.*v),-sin(3.*v));"
 "}"
 "vec4 n(vec4 v,vec4 s,float y)"
 "{"
   "float S=clamp(.5+.5*(s.w-v.w)/y,0.,1.);"
   "return mix(s,v,S)-vec4(0.,0.,0.,y*S*(1.-S));"
 "}"
 "vec3 v(vec3 v)"
 "{"
   "float S=sin(dot(v,vec3(7,157,113)));"
   "return fract(vec3(2097152,262144,32768)*S);"
 "}"
 "vec4 s(vec3 s)"
 "{"
   "float S=gl_Color.x*3000.*10.;"
   "vec4 i=vec4(0.);"
   "i.xyz=vec3(.3);"
   "i.w=min(min(s.y,-abs(s.z)+2.),-abs(s.x)+2.);"
   "vec4 y=i;"
   "for(int x=0;x<15;x++)"
     "{"
       "vec3 m=n(S*float(x*.2+1))*.2;"
       "if(x%3==1)"
         "m=m.zxy;"
       "if(x%3==2)"
         "m=m.zxy;"
       "m.y+=1.2;"
       "float M=.3;"
       "M+=(sin(s.x*40.)+cos(s.z*40.)+sin(s.y*40.))*.01;"
       "M+=(v(s)*.003).x;"
       "vec3 z=vec3(M>.33?100.:.2);"
       "vec4 w=vec4(z,length(m-s)-M);"
       "y=n(y,w,.3);"
     "}"
   "return y;"
 "}"
 "vec4 t(vec2 S)"
 "{"
   "float m=gl_Color.x*3000.*10.;"
   "vec2 y=(2.*S.xy-vec2(1280.,720.))/vec2(1280.,720.);"
   "float x=m*.2;"
   "vec3 w=vec3(sin(x)*-1.75,1.4+cos(0.)+2.,cos(x)*-1.75),i=w;"
   "i.y-=2.;"
   "float n=sin(m*5.);"
   "n=n*n;"
   "i.x+=n*.01;"
   "vec3 M=vec3(0.,1.,0.),z=normalize(M-i),c=normalize(cross(z,vec3(0.,1.,0.))),T=normalize(cross(c,z)),l=i+z,d=l+y.x*c+y.y*T,r=normalize(d-i);"
   "r+=v(r*.01)*.002;"
   "vec3 a=i;"
   "float k=0.,g=1.,b=float(MAX_STEPS);"
   "for(int N=0;N<MAX_STEPS;N++)"
     "{"
       "g=s(a).w;"
       "k+=g*STEP_MULTIPLIER;"
       "a=i+r*k;"
       "if(g<MIN_DIST)"
         "{"
           "b=float(N);"
           "break;"
         "}"
     "}"
   "vec2 N=vec2(NORMAL_OFFSET,0.);"
   "vec3 t=normalize(vec3(s(a+N.xyy).w-s(a-N.xyy).w,s(a+N.yxy).w-s(a-N.yxy).w,s(a+N.yyx).w-s(a-N.yyx).w)),e=i+r*k+t*SHADOW_OFFSET,o=e,E=normalize(w-a);"
   "float A=length(w-a),O=1.;"
   "k=0.;"
   "for(int P=0;P<MAX_STEPS_SHADOW;P++)"
     "{"
       "g=s(o).w;"
       "k+=g*STEP_MULTIPLIER;"
       "o=e+E*k;"
       "if(g<MIN_DIST)"
         "{"
           "O=0.;"
           "break;"
         "}"
       "O=min(O,SHADOW_HARDNESS*g/k);"
       "if(k>=A)"
         "{"
           "break;"
         "}"
       "if(P==MAX_STEPS_SHADOW-1)"
         "O=0.;"
     "}"
   "float P=max(0.,dot(t,E))*O+.1;"
   "vec3 I=P*s(a).xyz*(fract(a).x>.5?1.:.2);"
   "float D=length(a-i);"
   "vec4 H=vec4(I.xyz,0.);"
   "float F=.4*abs(1.-length(i-M)/D);"
   "F=max(.05,min(1.75,F));"
   "return vec4(H.xyz,F);"
 "}"
 "void main()"
 "{"
   "f=vec4(0.);"
   "for(int i=0;i<3;i++)"
     "f+=t(gl_FragCoord.xy+v(vec3(i)).xy);"
   "f/=3.;"
 "}";

#endif // SHADER_CODE_2_H_
